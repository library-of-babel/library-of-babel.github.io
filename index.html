<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- saved from url=(0034)https://mannequin-depth.github.io/ -->
<script src="https://cdn.jsdelivr.net/npm/@alch/alchemy-web3@latest/dist/alchemyWeb3.min.js"></script>
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link href="./misc_files/style.css" rel="stylesheet" type="text/css">
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-KPVR5NKSTV"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-KPVR5NKSTV');
</script>
</head>
<body>

<!-- Header -->
<div class="container" style="height:600px; width:600px; color: #eee">
    <img class="squiggle" src="./misc_files/squiggle1.svg" id="squiggy1" style="width:85%; transform: translate(-53%, -50%);"/>
    <div class="centered" style="width:300px">
      <p><span class="title">Welcome to the NFT Library of Babel</span></p>
      <p align="center">
        <br>
        <b>What do you want to link yourself to?</b>
        <br><br>
        Every unique piece of text up to 32 bytes long has a unique Non-Fungible Token (NFT).
        Anyone can mint their own token, but there can only be one owner for each.
        With nearly as many tokens as atoms in the universe, there's room for everyone.
      </p>
    </div>
</div>
<!-- Minting factory -->
<div style="width:600px; height:600px" align="center" class="container">
  <p>&nbsp;</p>
  <p align="center"><input type="text" id="text_entry" placeholder="Text"></p>
  <p align="center"><button onclick="onCheckTextField()" style="font-size: 18px;">Retrieve token</button></p>
  <div id="tokenIDs"><br><br></div>
  <div align="center" style="margin:0 auto;width: 90%%">
    <div style="float:left; width: 250px; height: 400px; margin: 0 auto; transform: translate(40%, 0);" id="minted">
      <img src="./misc_files/arrowdl.svg" id="lefty" style="width:70%"/>
      <div id="minted_text"> </div>
    </div>
    <div style="float:right; width: 250px; height: 400px; margin: 0 auto" id="unminted">
      <img src="./misc_files/arrowdr.svg" id="righty" style="width:70%; transform: translate(-50%, 0);"/>
      <div id="unminted_text"> </div>
      <p align="center"><button type="button" id="walletConnectButton" style="visibility:hidden;font-size: 18px;" onclick="connectWallet()">Connect wallet</button></p>
      <p align="center"><button type="button" id="mintNFTButton" style="visibility:hidden;font-size: 18px;" onclick="mintTheNFT()">Mint NFT</button></p>
    </div>
  </div>
</div>
<div class="spacer"></div>

<!-- FAQs -->
<div class="container" style="width:600px; color: #bbb">
    <div align="center" style="width:500px; margin: 0 auto">
      <p><span class="title">What's going on here?</span></p>
      <p><b>Hey, where's my jpeg?</b></p>
      <p>This NFT is as minimal as you can get.  There is no associated metadata, no bells or whistles.  The token ID is etched into the Ethereum blockchain with your "name" beside it, and that's all you get.</p>
      <p><b>I can mint this NFT myself?? and it's free?? How?</b></p>
      <p>To make the minting transaction, you must have an Ethereum wallet like <a href="https://metamask.io/">MetaMask</a>.  It's really easy to use -- just a browser extension that handles the signing of transactions on your behalf.  While anyone can mint and it's completely unrestricted, there is an unavoidable fee when making a change of state to the Ethereum blockchain.  This means you also need some ETH in the wallet.  Minting a few of these NFTs ourselves cost around $5-40 each (it's variable, depending on the instantaneous demands on the network).  Metamask will give you an estimate of the processing fee before you confirm, and then it should just take around a minute to get the confirmation.</p>
      <p><b>Wait so what do I own?</b></p>
      <p>You own a link to a numeric value.  That value is a unique identifier for whatever it is you entered.  If you own the identifier for the phrase "pepperoni pizza", you will be the only person on Earth with the link to "pepperoni pizza".
      You and everyone else can see the record of this on <a href="https://etherscan.io/token/0x734b03a053c1153c4A77E80911C00ecE3c3D163E">Etherscan</a> (you can also search for your wallet address, or the contract address below). You can list it on an NFT auction place like <a href="https://opensea.io/collection/babelnft">OpenSea</a>, though currently (without metadata attached to these tokens) it's a little barebones.</p>
      <p><b>How is the token ID produced?</b></p>
      <p>Token IDs on the Ethereum blockchain are stored in 256 bits = 32 bytes.  We use those 32 bytes directly, converting the text you entered into its byte representation in the same way your computer would when e.g. sending an email: by using Unicode to turn each character into 0s and 1s.  This means there is an upper limit on the size of the text entry, but 32 bytes gets you pretty far. For example: <br> <code><mark style="font-size: 16px">Brevity is the soul of wit.</mark></code> is 27 bytes.<b><u><br>**It is important to note that "love", "Love", and "LOVE" will are all different, and will therefore correspond to different tokens.**</u></b>  
      Unicode works for just about anything you can send by email, so ‚Ç¨, Ïñ¥Ïù¥, and üî• are all fair game, as they have a universally agreed upon representation in bytes (though they may take more than 1 byte per character, so the max number of characters is shorter).
      <p><b>Error: invalid something?</b></p>
      <p>Probably because you entered a piece of text that went over the 32-byte limit.
      If you want a token for longer things, or a unique token for something that is not text-based, see the section at the bottom of the page about hashing to produce the token ID!</p>
      <p><b>Library of Babel...?</b></p>
      <p>A ridiculously cool idea of Jorge Luis Borges of a fictional library which contains every possible book up to 410 pages long, by having one book per distinct combination of letters and punctuation.  While the vast majority of the library is utter nonsense, lying in its shelves are every book written and every book that will ever be written (up to the page limit). <br>Analogously, there is a unique NFT corresponding to every unique piece of text up to 32 bytes long, the vast majority of which are nonsense.  Within the possible NFTs lies nearly every person, place, thing, idea, feeling in every language.  When you broaden the interpretation of these token IDs to include hash values, there are 2<sup>256</sup>‚âà10<sup>77</sup> possible tokens to be minted, in the same ballpark as the number of atoms in the universe (estimated at ~10<sup>82</sup>).  Considering you can hash anything that can be serialized, the sheer number of possibilities means a unique token for an incomprehensibly large quantity of ... well, anything. </p>
      <p><b>Contract address</b></p>
      <p><code><mark>0x734b03a053c1153c4A77E80911C00ecE3c3D163E</mark></code></p>
      <p></p>
    </div>
</div>
<div style="width:600px;" align="center" class="container">
  <div align="center">
    <br>
    <p align="center" style="font-size: 24px">Turn a token ID back into the characters it represents</p>
    <p align="center"><input type="text" id="enteredTokenID" placeholder="Token ID"></p>
    <p align="center"><button onclick="decodeTokenID()" style="font-size: 18px;">Decode</button></p>
    <div id="decodedTokenIDs" style="font-size: 18px;"><br></div>
    <br>
    <p align="center">Note: if the tokenID was not generated from a piece of text (for example, it's the hash of something, or just a numeric ID for its own sake (see below)), the output here will be uninterpretable.
  </div>
  <p align="center" style="font-size: 24px;">Advanced Features</p>
  <p align="center"><input type="checkbox" id="shouldIHash">Perform hash?
    <br> At the end of the day, each token corresponds to a unique 256-bit value.  We can just as easily use a hashing function to produce the token ID, which allows arbitrarily sized inputs.  The full works of Shakespeare can be reduced to a single ID and therefor a unique token, though changes in the ordering or even the addition an extra space at the end of a single sentence will change the hash.  Check this box to hash the input using the most commonly accepted SHA-256 algorithm, and use the hash as the token ID. For texts longer than a sentence (and certainly for anything other than text, like an mp3 or pdf), prefer hashing elsewhere and using the option below.  Won't there be collisions between the 32 byte textual tokens, and hash tokens?  No, due to the astronomical number of tokens possible.</p>
  <p align="center"><input type="checkbox" id="rawValue">Raw ID value?<br> If you hash elsewhere, or just want a particular number tokenID (e.g. the number 1000), check this box so that the value you enter is the token ID.  If the value starts with <code><mark>0x</mark></code>, it will be interpreted as hex, otherwise as decimal (base 10).</p>
</div>
<div style="clear: both;"></div>

<div align="center" class="centered2" style="height:200px;width:200px;">
  <img src="./misc_files/babelNFT.gif" style="width:70%"/>
</div>
<script type="text/javascript">

let textField;
let tokenID;
let publicKey;
let walletConnected = false;
let myContract;

const contractAddress = "0x734b03a053c1153c4A77E80911C00ecE3c3D163E";
const contractABI = [{"inputs": [],"stateMutability": "nonpayable","type": "constructor"},{"anonymous": false,"inputs": [{"indexed": true,"internalType": "address","name": "owner","type": "address"},{"indexed": true,"internalType": "address","name": "approved","type": "address"},{"indexed": true,"internalType": "uint256","name": "tokenId","type": "uint256"}],"name": "Approval","type": "event"},{"anonymous": false,"inputs": [{"indexed": true,"internalType": "address","name": "owner","type": "address"},{"indexed": true,"internalType": "address","name": "operator","type": "address"},{"indexed": false,"internalType": "bool","name": "approved","type": "bool"}],"name": "ApprovalForAll","type": "event"},{"anonymous": false,"inputs": [{"indexed": true,"internalType": "address","name": "from","type": "address"},{"indexed": true,"internalType": "address","name": "to","type": "address"},{"indexed": true,"internalType": "uint256","name": "tokenId","type": "uint256"}],"name": "Transfer","type": "event"},{"inputs": [{"internalType": "address","name": "to","type": "address"},{"internalType": "uint256","name": "tokenId","type": "uint256"}],"name": "approve","outputs": [],"stateMutability": "nonpayable","type": "function"},{"inputs": [{"internalType": "address","name": "owner","type": "address"}],"name": "balanceOf","outputs": [{"internalType": "uint256","name": "","type": "uint256"}],"stateMutability": "view","type": "function"},{"inputs": [{"internalType": "uint256","name": "tokenId","type": "uint256"}],"name": "getApproved","outputs": [{"internalType": "address","name": "","type": "address"}],"stateMutability": "view","type": "function"},{"inputs": [{"internalType": "address","name": "owner","type": "address"},{"internalType": "address","name": "operator","type": "address"}],"name": "isApprovedForAll","outputs": [{"internalType": "bool","name": "","type": "bool"}],"stateMutability": "view","type": "function"},{"inputs": [{"internalType": "address","name": "recipient","type": "address"},{"internalType": "bytes32","name": "b32hash","type": "bytes32"}],"name": "mintNFT","outputs": [{"internalType": "uint256","name": "","type": "uint256"}],"stateMutability": "nonpayable","type": "function"},{"inputs": [],"name": "name","outputs": [{"internalType": "string","name": "","type": "string"}],"stateMutability": "view","type": "function"},{"inputs": [{"internalType": "uint256","name": "tokenId","type": "uint256"}],"name": "ownerOf","outputs": [{"internalType": "address","name": "","type": "address"}],"stateMutability": "view","type": "function"},{"inputs": [{"internalType": "address","name": "from","type": "address"},{"internalType": "address","name": "to","type": "address"},{"internalType": "uint256","name": "tokenId","type": "uint256"}],"name": "safeTransferFrom","outputs": [],"stateMutability": "nonpayable","type": "function"},{"inputs": [{"internalType": "address","name": "from","type": "address"},{"internalType": "address","name": "to","type": "address"},{"internalType": "uint256","name": "tokenId","type": "uint256"},{"internalType": "bytes","name": "_data","type": "bytes"}],"name": "safeTransferFrom","outputs": [],"stateMutability": "nonpayable","type": "function"},{"inputs": [{"internalType": "address","name": "operator","type": "address"},{"internalType": "bool","name": "approved","type": "bool"}],"name": "setApprovalForAll","outputs": [],"stateMutability": "nonpayable","type": "function"},{"inputs": [{"internalType": "bytes4","name": "interfaceId","type": "bytes4"}],"name": "supportsInterface","outputs": [{"internalType": "bool","name": "","type": "bool"}],"stateMutability": "view","type": "function"},{"inputs": [],"name": "symbol","outputs": [{"internalType": "string","name": "","type": "string"}],"stateMutability": "view","type": "function"},{"inputs": [{"internalType": "uint256","name": "tokenId","type": "uint256"}],"name": "tokenURI","outputs": [{"internalType": "string","name": "","type": "string"}],"stateMutability": "view","type": "function"},{"inputs": [{"internalType": "address","name": "from","type": "address"},{"internalType": "address","name": "to","type": "address"},{"internalType": "uint256","name": "tokenId","type": "uint256"}],"name": "transferFrom","outputs": [],"stateMutability": "nonpayable","type": "function"
    }
  ],

API_URL = "https://eth-mainnet.alchemyapi.io/v2/aNuJmwSx78k2fZoMSPQB5lZ90jmGBhgc";
const web3 = AlchemyWeb3.createAlchemyWeb3(API_URL)
myContract = new web3.eth.Contract(contractABI, contractAddress);

async function connectWallet () {
  if (typeof window.ethereum !== 'undefined') { //check if Metamask is installed
    try {
        console.log(publicKey);
        const accounts = await ethereum.request({ method: 'eth_requestAccounts' });
        publicKey = accounts[0];
        console.log(publicKey);
        walletConnected = true;
        document.getElementById("walletConnectButton").style.visibility = "hidden";
        document.getElementById("mintNFTButton").style.visibility = "visible";
      } catch (error) {
        walletConnected = false;
        window.alert("ü¶ä Connect to Metamask using the button on the top right.");
      }
    } else {
    walletConnected = false;
    window.alert("ü¶ä You must install Metamask into your browser: https://metamask.io/download.html");
  }
}

async function requestApproval() {
  //Will Start the metamask extension
  connectWallet();
  if (walletConnected) {
    const accounts = await ethereum.request({ method: 'eth_requestAccounts' });
    if (accounts.length > 0) {
      publicKey = accounts[0];
      document.getElementById("walletConnectButton").style.visibility = "hidden";
      document.getElementById("mintNFTButton").style.visibility = "visible";
      walletConnected = true;
  } else {
    window.alert("Error connecting wallet")
  }
  }
}
async function hashMessage() {
  tokenID = hex(await crypto.subtle.digest('SHA-256', tokenID));
}

const byteToHex = [];
for (let n = 0; n <= 0xff; ++n)
{
    const hexOctet = n.toString(16).padStart(2, "0");
    byteToHex.push(hexOctet);
}
function hex(arrayBuffer) {
    const buff = new Uint8Array(arrayBuffer);
    const hexOctets = [];
    for (let i = 0; i < buff.length; ++i)
        hexOctets.push(byteToHex[buff[i]]);

    return "0x"+hexOctets.join("");
}
function hexToBytes(hex) {
  // starting at 2 skips over the 0x
    for (var bytes = [], c = 2; c < hex.length; c += 2)
    bytes.push(parseInt(hex.substr(c, 2), 16));
    return new Uint8Array(bytes);
}
function mintTheNFT() {
  const data = myContract.methods.mintNFT(publicKey, tokenID).encodeABI();
  const tx = {
   'from': publicKey,
   'to': contractAddress,
   // 'nonce': nonce,
   // 'gas': 500000,
   'data': data,
  };
  console.log("Data", data);
  const txHash = ethereum.request({method: 'eth_sendTransaction', params: [tx]}).then((hash) => {
    console.log("The hash of your transaction is: ", hash);
  }).catch((err) => {
      console.log("Something went wrong when submitting your transaction:", err);
    })
}
async function onCheckTextField() {
  textField = document.getElementById("text_entry").value;
  console.log(textField);
  if (document.getElementById("rawValue").checked) {
    if (textField.slice(0, 2) == '0x') { // interpret as hex
      tokenID = textField;
    } else { // interpret as decimal
      tokenID = BigInt(textField).toString(16);
    }
  } else {
    tokenID = new TextEncoder().encode(textField);
    if (document.getElementById("shouldIHash").checked) {
      await hashMessage();
    } else {
      tokenID = hex(tokenID);
    }
  }
  tokenID = '0x' + web3.utils.padLeft(tokenID.replace('0x', ''), 64);
  backTranslation = new TextDecoder().decode(hexToBytes(tokenID));
  decimalTranslation = BigInt(tokenID).toString(10);
  document.getElementById("tokenIDs").innerHTML = "Token ID: <code><mark>"+tokenID+"</mark></code><br>Decimal token ID: <code><mark>"+decimalTranslation+"</mark></code>";
  try {
    myContract.methods.ownerOf(tokenID).call().then((returned) => {
      // It's already owned: display the owner
      document.getElementById("lefty").style.filter = "invert(0.9)";
      document.getElementById("righty").style.filter = "";
      document.getElementById("minted_text").innerHTML = "Already minted!  Belongs to: <br> <code><mark>"+returned+"</mark></code>";
      document.getElementById("unminted_text").innerHTML = "";
      document.getElementById("walletConnectButton").style.visibility = "hidden";
      document.getElementById("mintNFTButton").style.visibility = "hidden";
    }).catch(error => {
      console.log(error.message);
      if (error.message.includes("nonexistent token")) {
        // Unminted, display option to buy
        document.getElementById("lefty").style.filter = "";
        document.getElementById("righty").style.filter = "invert(0.9)";
        document.getElementById("unminted_text").innerHTML = "Token has not been minted yet! <br> Would you like to mint it?";
        document.getElementById("minted_text").innerHTML = "";
        if (!walletConnected) {
          document.getElementById("walletConnectButton").style.visibility = "visible";
        } else {
          document.getElementById("mintNFTButton").style.visibility = "visible";
        }
      } else {
        window.alert("Bad query: "+error.message);
      }
    })
  } catch(e) {
    window.alert("Really bad query: "+e.message);
    console.log(e.message);
  }}
async function decodeTokenID() {
  var enteredTokenID = document.getElementById("enteredTokenID").value;
  try {
    if (enteredTokenID.slice(0, 2) !== '0x') { // interpret as decimal
      enteredTokenID = BigInt(enteredTokenID).toString(16);
    }
    enteredTokenID = '0x' + web3.utils.padLeft(enteredTokenID.replace('0x', ''), 64);
    console.log(enteredTokenID);
    backTranslation = new TextDecoder().decode(hexToBytes(enteredTokenID));
    document.getElementById("decodedTokenIDs").innerHTML = "Decoded: <code><mark>"+backTranslation+"</mark></code>";
  } catch (error) {
    window.alert("Bad decode ID; "+error);
  }
}
</script>
</body>
</html>